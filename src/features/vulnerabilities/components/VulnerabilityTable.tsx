import {
  Box,
  Text,
  Input,
  Flex,
  Portal,
  Select,
  createListCollection,
  Table,
  IconButton,
  Switch, 
  HStack 
} from '@chakra-ui/react'
import {
  useReactTable,
  getCoreRowModel,
  getFilteredRowModel,
  getSortedRowModel,
  flexRender,
  ColumnDef,
  ColumnFiltersState,
  SortingState,
  Row,
} from '@tanstack/react-table'
import { useVirtualizer, VirtualItem } from '@tanstack/react-virtual'
import { useMemo, useState, useRef, useEffect } from 'react'
import { FlattenedVulnerability } from '../../types'
import { Link as RouterLink } from 'react-router-dom'
import VulnerabilitiesExport from './VulnerabilityExport'
import CompareWindow from './CompareWindow'
import { FiExternalLink } from 'react-icons/fi'
import { useColorModeValue } from '@/components/ui/color-mode'

interface Props {
  data: FlattenedVulnerability[]
  fetchNextPage: () => void
  hasNextPage: boolean
  isFetchingNextPage: boolean
}

// Define options and create Chakra-compatible select collections
const severityOptions = ['critical', 'high', 'medium', 'low']
const kaiStatusOptions = ['invalid - norisk', 'ai-invalid-norisk']

export const severityCollection = createListCollection({
  items: severityOptions.map((s) => ({ label: s.toUpperCase(), value: s })),
})

export const kaiStatusCollection = createListCollection({
  items: kaiStatusOptions.map((s) => ({ label: s, value: s })),
})

export const VulnerabilityTable = ({ data, fetchNextPage, hasNextPage, isFetchingNextPage }: Props) => {
  // Table filter and sort state
  const [globalFilter, setGlobalFilter] = useState<string>('')
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([])
  const [sorting, setSorting] = useState<SortingState>([])

  // Ref to contain the scrollable area for virtualization
  const tableContainerRef = useRef<HTMLDivElement>(null)

  // State for comparing vulnerabilities
  const [compareItems, setCompareItems] = useState<FlattenedVulnerability[]>([])
  useEffect(() => {

  })
  // Add an item to the compare list
  const openCompare = (item: FlattenedVulnerability) => {
    setCompareItems((prev) => [...prev, item])
  }

  // Remove an item from the compare list by index
  const closeCompare = (index: number) => {
    setCompareItems((prev) => prev.filter((_, i) => i !== index))
  }

  // Define table columns using TanStack Table
  const columns = useMemo<ColumnDef<FlattenedVulnerability>[]>(() => [
    {
      accessorKey: 'cve',
      header: 'CVE',
      cell: (info) => {
        const vuln = info.row.original
        return (
          <Flex align="center" justify="space-between">
            <Text as={RouterLink} to={`/vulnerabilities/${info.getValue()}`} color="blue.500">
              {info.getValue()}
            </Text>
            <IconButton
              size="xs"
              aria-label="Compare CVE"
              variant="ghost"
              onClick={() => openCompare(vuln)}
            >
              <FiExternalLink />
            </IconButton>
          </Flex>
        )
      },
    },
    {
      accessorKey: 'severity',
      header: 'Severity',
      filterFn: 'arrIncludesSome',
      meta: { filterVariant: 'multi-select' },
    },
    {
      accessorKey: 'packageName',
      header: 'Package',
    },
    {
      accessorFn: (row) => `${row.imageName}:${row.imageVersion}`,
      id: 'image',
      header: 'Image',
    },
    {
      accessorKey: 'kaiStatus',
      header: 'Kai Status',
      filterFn: 'arrIncludesNone',
      meta: { filterVariant: 'select' },
    },
  ], [])

  // Initialize the table instance
  const table = useReactTable({
    data,
    columns,
    state: { globalFilter, columnFilters, sorting },
    onGlobalFilterChange: setGlobalFilter,
    onColumnFiltersChange: setColumnFilters,
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getSortedRowModel: getSortedRowModel(),
    filterFns: {
      arrIncludesSome: (row: Row<FlattenedVulnerability>, columnId: string, filterValue: string[]) => {
        if (!filterValue?.length) return true
        return filterValue.includes(row.getValue(columnId))
      },
      arrIncludesNone: (row: Row<FlattenedVulnerability>, columnId: string, filterValue: string[]) => {
        if (!filterValue?.length) return true
        return !filterValue.includes(row.getValue(columnId))
      },
    },
  })

  // Setup virtualizer for large row rendering
  const rowVirtualizer = useVirtualizer({
    count: table.getRowModel().rows.length,
    getScrollElement: () => tableContainerRef.current,
    estimateSize: () => 40,
    overscan: 5,
  })

  const virtualRows: VirtualItem[] = rowVirtualizer.getVirtualItems()
  const totalSize = rowVirtualizer.getTotalSize()

  useEffect(() => {
    if (!hasNextPage || isFetchingNextPage) return
  
    const lastItem = virtualRows[virtualRows.length - 1]
    if (!lastItem) return
  
    const padding = 10 // How close to end of list to trigger loading
    if (lastItem.index >= data.length - padding) {
      fetchNextPage()
    }
  }, [virtualRows, hasNextPage, isFetchingNextPage, data.length, fetchNextPage])

  // Responsive table layout
  const gridTemplate = `repeat(${columns.length}, 1fr)`

  // Theme-aware row and header colors
  const evenRowBg = useColorModeValue('#fff', 'gray.700')
  const oddRowBg = useColorModeValue('#f9f9f9', 'gray.800')
  const headerBg = useColorModeValue('white', 'gray.900')

  const [kaiStatusFilter, setKaiStatusFilter] = useState<string[]>(
    () => (table.getColumn('kaiStatus')?.getFilterValue() as string[]) ?? []
  )
  useEffect(() => {
    table.getColumn('kaiStatus')?.setFilterValue(
      kaiStatusFilter.length ? kaiStatusFilter : undefined
    )
  }, [kaiStatusFilter])

  return (
    <Box>
      {/* Export Controls */}
      <Flex gap={3} mb={2} justifyContent="flex-end">
        <VulnerabilitiesExport table={table} data={data} />
      </Flex>

      {/* Filters */}
      <Flex mb={4} gap={4} wrap="wrap" align="center">
        <Input
          placeholder="Filter by CVE, package, image..."
          value={globalFilter}
          onChange={(e) => setGlobalFilter(e.target.value)}
          maxW="320px"
          size="sm"
        />

        {/* Severity Filter */}
        <Select.Root
          value={table.getColumn('severity')?.getFilterValue() ?? []}
          onValueChange={(e) => table.getColumn('severity')?.setFilterValue(e.value)}
          collection={severityCollection}
          multiple
          deselectable
          size="sm"
          width="200px"
        >
          <Select.HiddenSelect />
          <Select.Control>
            <Select.Trigger>
              <Select.ValueText placeholder="Filter by severity" />
            </Select.Trigger>
            <Select.IndicatorGroup>
              <Select.Indicator />
            </Select.IndicatorGroup>
          </Select.Control>
          <Portal>
            <Select.Positioner>
              <Select.Content>
                {severityCollection.items.map((item) => (
                  <Select.Item key={item.value} item={item}>
                    {item.label}
                    <Select.ItemIndicator />
                  </Select.Item>
                ))}
              </Select.Content>
            </Select.Positioner>
          </Portal>
        </Select.Root>

        {/* Kai Status Filter */}
        {/* <Select.Root
          value={table.getColumn('kaiStatus')?.getFilterValue() ?? []}
          onValueChange={(e) => {
            const selected = e.value
            table.getColumn('kaiStatus')?.setFilterValue(selected.length ? selected : undefined)
          }}
          collection={kaiStatusCollection}
          multiple
          deselectable
          size="sm"
          width="250px"
        >
          <Select.HiddenSelect />
          <Select.Control>
            <Select.Trigger>
              <Select.ValueText placeholder="Filter Out Kai Status" />
            </Select.Trigger>
            <Select.IndicatorGroup>
              <Select.Indicator />
            </Select.IndicatorGroup>
          </Select.Control>
          <Portal>
            <Select.Positioner>
              <Select.Content>
                {kaiStatusCollection.items.map((item) => (
                  <Select.Item key={item.value} item={item}>
                    {item.label}
                    <Select.ItemIndicator />
                  </Select.Item>
                ))}
              </Select.Content>
            </Select.Positioner>
          </Portal>
        </Select.Root> */}
        <Box>
        <HStack spacing={4}>
          {kaiStatusOptions.map((status) => {
            const isChecked = !kaiStatusFilter.includes(status) // status not excluded
            return (
              <HStack key={status} align="center">
                <Switch.Root
                  checked={isChecked}
                  onCheckedChange={({ checked }) => {
                    setKaiStatusFilter((prev) =>
                      checked
                        ? prev.filter((s) => s !== status) // allow
                        : [...prev, status] // exclude
                    )
                  }}
                >
                  <Switch.HiddenInput />
                  <Switch.Control>
                    <Switch.Thumb />
                  </Switch.Control>
                  <Switch.Label fontSize="sm">{status}</Switch.Label>
                </Switch.Root>
              </HStack>
            )
          })}
      </HStack>
      </Box>
        <Text fontSize="sm" color="gray.500">
          Showing {table.getFilteredRowModel().rows.length} results
        </Text>
      </Flex>

      {/* Virtualized Table */}
      <Box
        ref={tableContainerRef}
        overflow="auto"
        height="600px"
        position="relative"
      >
        <Table.Root style={{ display: 'grid', width: '100%' }}>
          {/* Table Header */}
          <Table.Header
            style={{
              display: 'grid',
              gridTemplateColumns: gridTemplate,
              position: 'sticky',
              top: 0,
              zIndex: 1,
              background: headerBg,
              textAlign: 'left',
            }}
          >
            {table.getHeaderGroups().map((headerGroup) => (
              <Table.Row key={headerGroup.id} style={{ display: 'contents' }}>
                {headerGroup.headers.map((header) => (
                  <Table.ColumnHeader
                    key={header.id}
                    style={{
                      padding: '8px',
                      borderBottom: '1px solid #eee',
                      fontWeight: 600,
                      background: headerBg,
                    }}
                  >
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </Table.ColumnHeader>
                ))}
              </Table.Row>
            ))}
          </Table.Header>

          {/* Table Body */}
          <Table.Body
            style={{
              display: 'block',
              height: `${totalSize}px`,
              position: 'relative',
            }}
          >
            {virtualRows.map((virtualRow) => {
              const row = table.getRowModel().rows[virtualRow.index]
              return (
                <Table.Row
                  key={row.id}
                  data-index={virtualRow.index}
                  ref={(el) => rowVirtualizer.measureElement(el)}
                  style={{
                    display: 'grid',
                    gridTemplateColumns: gridTemplate,
                    transform: `translateY(${virtualRow.start}px)`,
                    position: 'absolute',
                    width: '100%',
                    background: virtualRow.index % 2 ? oddRowBg : evenRowBg,
                    textAlign: 'left',
                  }}
                >
                  {row.getVisibleCells().map((cell) => (
                    <Table.Cell
                      key={cell.id}
                      style={{
                        padding: '8px',
                        borderBottom: '1px solid #eee',
                      }}
                    >
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </Table.Cell>
                  ))}
                </Table.Row>
              )
            })}
          </Table.Body>
        </Table.Root>
      </Box>

      {/* Compare Modal(s) */}
      {compareItems.map((vuln, i) => (
        <CompareWindow key={i} data={vuln} onClose={() => closeCompare(i)} />
      ))}
    </Box>
  )
}
